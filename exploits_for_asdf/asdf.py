# find_collision_mp.py
import hashlib
import struct
import random
import sys
from multiprocessing import Process, Queue, cpu_count

PREFIX = b"HackQuest2025"

def f(x: int) -> int:
    xb = struct.pack("<Q", x)
    h = hashlib.sha256(PREFIX + xb).digest()
    return struct.unpack("<Q", h[:8])[0]

def find_collision(start: int) -> tuple[int,int]:
    # Brent’s cycle-finding from arbitrary start
    power = lam = 1
    tortoise = f(start)
    hare     = f(f(start))
    while tortoise != hare:
        if power == lam:
            tortoise = hare
            power <<= 1
            lam = 0
        hare = f(hare)
        lam += 1

    # λ 주기만큼 떨어진 지점 찾기
    mu = 0
    tortoise = hare = start
    for _ in range(lam):
        hare = f(hare)
    while tortoise != hare:
        tortoise = f(tortoise)
        hare     = f(hare)
        mu += 1

    # 충돌점 두 개(x, y) 얻기
    x = tortoise
    y = tortoise
    for _ in range(lam):
        y = f(y)
    return x, y

def worker(start: int, out: Queue):
    a, b = find_collision(start)
    if a != b:
        out.put((a, b))

if __name__ == "__main__":
    nprocs = cpu_count()
    q = Queue()
    procs = []
    # 워커 시작
    for _ in range(nprocs):
        seed = random.randrange(1 << 64)
        p = Process(target=worker, args=(seed, q), daemon=True)
        p.start()
        procs.append(p)

    # 첫 결과 받기
    a, b = q.get()
    # 나머지 워커 종료
    for p in procs:
        p.terminate()

    msg_a = struct.pack("<Q", a)
    msg_b = struct.pack("<Q", b)
    ha = hashlib.sha256(PREFIX + msg_a).hexdigest()[:16]
    hb = hashlib.sha256(PREFIX + msg_b).hexdigest()[:16]

    print("=== 충돌 찾기 완료 ===")
    print(f"Message A (hex): {msg_a.hex()}")
    print(f"Message B (hex): {msg_b.hex()}")
    print(f"공통 해시 (앞16 hex): {ha}")
    print("======================")
    # 검증
    assert ha == hb, "충돌 실패!"
    print("Flag 분기 통과용 메시지 두 개가 준비되었습니다.")
